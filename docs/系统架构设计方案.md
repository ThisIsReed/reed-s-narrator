# 故事叙述者系统 — 系统架构设计方案

## Context

根据 `docs/` 下三份文档（核心用户观点、综合评审意见、初版 User Story），需要构建一个"无玩家介入"的故事演化引擎。核心挑战在于：统一时间基线、信息隔离、LLM 调用成本控制、确定性结算与可重放。本方案以 **Python + SQLite + 多 LLM 抽象** 为技术栈，按照四层架构设计，确保强可维护性和强可扩展性。

---

## 1. 项目目录结构

```
reed-narrator/
├── pyproject.toml                  # 项目配置 (dependencies, scripts, metadata)
├── config/
│   ├── default.yaml                # 默认配置
│   └── schemas/
│       └── action_whitelist.yaml   # 动作白名单定义
│
├── src/
│   └── narrator/
│       ├── __init__.py
│       │
│       ├── core/                   # Layer 1: Simulation Core（确定性层）
│       │   ├── __init__.py
│       │   ├── clock.py            # GlobalTick 时钟管理
│       │   ├── rule_engine.py      # 规则结算引擎（移动/战斗/资源/状态效果）
│       │   ├── interrupt.py        # 中断管理器
│       │   └── seed.py             # 全局随机种子管理
│       │
│       ├── orchestrator/           # Layer 2: Narrative Orchestrator（半确定性层）
│       │   ├── __init__.py
│       │   ├── narrator_ctrl.py    # Narrator 中央控制器（主循环入口）
│       │   ├── granularity.py      # 叙事粒度决策（年/月/日/即时）
│       │   ├── spotlight.py        # 聚光灯选角（Active/Passive/Dormant）
│       │   ├── event_pool.py       # 事件池生成与管理
│       │   └── drama_energy.py     # 戏剧能量池（叙事张力管理）
│       │
│       ├── agents/                 # Layer 3: Agent LLM Layer（非确定性层）
│       │   ├── __init__.py
│       │   ├── character_agent.py  # 角色 Agent（生成意图+文案）
│       │   ├── dm_agent.py         # DM Agent（无状态结算执行）
│       │   ├── intent.py           # 意图数据结构 & 校验器
│       │   └── retry.py            # 重试 & Fallback 机制
│       │
│       ├── knowledge/              # Layer 4: Knowledge & Diffusion Layer
│       │   ├── __init__.py
│       │   ├── fact_store.py       # 客观事实存储
│       │   ├── belief_store.py     # 角色主观认知
│       │   ├── propagation.py      # 信息传播图 & 延迟机制
│       │   └── rumor.py            # 传闻系统
│       │
│       ├── phenology/              # 物候系统（独立特色模块）
│       │   ├── __init__.py
│       │   ├── calendar.py         # 物候日历（季节/气候/节庆）
│       │   ├── effects.py          # 物候硬约束效果（资源/疾病/迁徙/冲突）
│       │   └── registry.py         # 物候规则注册表（可扩展）
│       │
│       ├── llm/                    # LLM 抽象层
│       │   ├── __init__.py
│       │   ├── base.py             # LLMProvider 抽象基类
│       │   ├── openai.py           # OpenAI 实现
│       │   ├── anthropic.py        # Anthropic 实现
│       │   ├── ollama.py           # 本地模型实现
│       │   ├── router.py           # Provider 路由 & 负载分配
│       │   └── schemas.py          # 结构化输出 Schema 定义
│       │
│       ├── models/                 # 领域模型（纯数据结构）
│       │   ├── __init__.py
│       │   ├── character.py        # Character 数据模型
│       │   ├── event.py            # Event 数据模型
│       │   ├── world.py            # WorldState 数据模型
│       │   ├── action.py           # Action & ActionResult 模型
│       │   └── enums.py            # 枚举定义（StateMode, Granularity 等）
│       │
│       ├── persistence/            # 持久化层
│       │   ├── __init__.py
│       │   ├── database.py         # SQLite 连接管理 & 迁移
│       │   ├── repositories.py     # Repository 模式（CRUD 封装）
│       │   ├── checkpoint.py       # 存档 & 恢复
│       │   └── migrations/         # 数据库迁移脚本
│       │       └── 001_init.sql
│       │
│       └── config.py               # 配置加载 & 校验
│
├── tests/
│   ├── unit/                       # 单元测试（按模块镜像）
│   │   ├── core/
│   │   ├── orchestrator/
│   │   ├── agents/
│   │   ├── knowledge/
│   │   ├── phenology/
│   │   └── llm/
│   ├── integration/                # 集成测试
│   │   ├── test_main_loop.py       # 主循环端到端
│   │   ├── test_replay.py          # 重放一致性
│   │   └── test_isolation.py       # 信息隔离验证
│   └── conftest.py                 # pytest fixtures
│
└── scripts/
    ├── run.py                      # 启动入口
    └── replay.py                   # 重放调试工具
```

---

## 2. 模块职责与边界

### Layer 1: `core/` — Simulation Core（确定性层）
| 模块 | 职责 | 不负责 |
|---|---|---|
| `clock.py` | 管理 GlobalTick，单调递增，提供 tick→日期映射 | 不决定叙事粒度 |
| `rule_engine.py` | 执行确定性状态变更（移动、战斗、资源消耗、状态效果过期） | 不生成叙事文案 |
| `interrupt.py` | 检测中断条件，打断长程任务 | 不决定是否中断（由 Narrator 决策） |
| `seed.py` | 管理全局 RNG，支持 fork 子种子给不同子系统 | — |

### Layer 2: `orchestrator/` — Narrative Orchestrator（半确定性层）
| 模块 | 职责 | 不负责 |
|---|---|---|
| `narrator_ctrl.py` | 主循环入口，串联所有层，裁定 APPROVE/REJECT | 不直接调 LLM |
| `granularity.py` | 决定本轮时间粒度（年/月/日/即时），输出理由 | 不推进时间 |
| `spotlight.py` | 按公式计算角色激活分，分层 Active/Passive/Dormant | 不执行角色行动 |
| `event_pool.py` | 生成/刷新事件，计算影响传播范围 | 不改写世界状态 |
| `drama_energy.py` | 追踪叙事张力，在平淡期积累、高潮期释放 | — |

### Layer 3: `agents/` — Agent LLM Layer（非确定性层）
| 模块 | 职责 | 不负责 |
|---|---|---|
| `character_agent.py` | 调用 LLM 生成角色意图（`intent` + `flavor_text`） | 不修改世界状态 |
| `dm_agent.py` | 无状态 DM，接收打包上下文，输出结算结果 | 不持有会话状态 |
| `intent.py` | Intent 数据定义、动作白名单校验、参数合法性检查 | — |
| `retry.py` | 管理重试计数、fallback 生成与标记 | — |

### Layer 4: `knowledge/` — Knowledge & Diffusion Layer
| 模块 | 职责 | 不负责 |
|---|---|---|
| `fact_store.py` | 存储客观事实（全局真相） | 不决定谁能看到 |
| `belief_store.py` | 管理角色主观认知（每角色独立视图） | 不生成新知识 |
| `propagation.py` | 信息传播图，延迟扩散，距离衰减 | — |
| `rumor.py` | 传闻机制（失真传播、可信度追踪） | — |

### 独立模块: `phenology/` — 物候系统
| 模块 | 职责 |
|---|---|
| `calendar.py` | 根据 tick 计算当前季节、气候、节庆 |
| `effects.py` | 将物候状态转化为硬数值约束（严冬行军惩罚、雨季疾病提升、歉收降粮） |
| `registry.py` | 可扩展的物候规则注册表，支持插件式添加新规则 |

---

## 3. 核心接口设计（可扩展性关键）

### 3.1 LLM Provider 抽象

```python
# src/narrator/llm/base.py
from abc import ABC, abstractmethod
from typing import TypeVar, Type
from pydantic import BaseModel

T = TypeVar("T", bound=BaseModel)

class LLMProvider(ABC):
    """LLM 提供商抽象基类 — 新增 Provider 只需实现此接口"""

    @abstractmethod
    async def generate(
        self,
        system_prompt: str,
        user_prompt: str,
        response_schema: Type[T],
        temperature: float = 0.7,
        max_tokens: int = 2048,
        seed: int | None = None,
    ) -> T:
        """生成结构化输出，返回解析后的 Pydantic 模型"""
        ...

    @abstractmethod
    async def health_check(self) -> bool:
        ...
```

### 3.2 规则引擎扩展

```python
# src/narrator/core/rule_engine.py
from abc import ABC, abstractmethod

class Rule(ABC):
    """规则基类 — 新增规则类型只需继承此类并注册"""
    priority: int = 0  # 越小越先执行

    @abstractmethod
    def condition(self, world: WorldState, context: SettlementContext) -> bool:
        """判断规则是否触发"""
        ...

    @abstractmethod
    def apply(self, world: WorldState, context: SettlementContext) -> list[StateChange]:
        """执行规则，返回状态变更列表"""
        ...

class RuleEngine:
    def __init__(self):
        self._rules: list[Rule] = []

    def register(self, rule: Rule) -> None:
        """注册新规则（支持插件式扩展）"""
        ...

    def settle(self, world: WorldState, context: SettlementContext) -> SettlementResult:
        """按优先级执行所有匹配规则，返回合并后的结算结果"""
        ...
```

### 3.3 物候效果扩展

```python
# src/narrator/phenology/registry.py
class PhenologyEffect(ABC):
    """物候效果基类 — 新增物候约束只需继承并注册"""

    @abstractmethod
    def evaluate(self, season: Season, climate: Climate, world: WorldState) -> list[StateModifier]:
        """根据当前物候状态返回数值修正列表"""
        ...

class PhenologyRegistry:
    def register(self, effect: PhenologyEffect) -> None: ...
    def apply_all(self, season, climate, world) -> list[StateModifier]: ...
```

### 3.4 事件扩展

```python
# src/narrator/orchestrator/event_pool.py
class EventGenerator(ABC):
    """事件生成器基类 — 新增事件来源只需实现此接口"""

    @abstractmethod
    def generate(self, world: WorldState, tick: int) -> list[Event]:
        ...
```

---

## 4. 依赖流（单向，无循环）

```
config.py
   │
   ▼
models/          ◄── 纯数据结构，无外部依赖
   │
   ▼
core/            ◄── 仅依赖 models/
   │
   ▼
persistence/     ◄── 依赖 models/
   │
   ▼
phenology/       ◄── 依赖 models/, core/
   │
   ▼
knowledge/       ◄── 依赖 models/, persistence/
   │
   ▼
llm/             ◄── 依赖 models/ (用于 schema 定义)
   │
   ▼
agents/          ◄── 依赖 models/, llm/, knowledge/
   │
   ▼
orchestrator/    ◄── 依赖所有上层，是唯一的"组装层"
```

**关键原则**：依赖箭头严格向下，上层模块不可导入下层模块。`orchestrator/narrator_ctrl.py` 是唯一允许跨层调用的组装入口。

---

## 5. 主循环流程

```python
# narrator_ctrl.py 伪代码
class NarratorController:
    async def run_tick(self) -> TickResult:
        # 1. 推进 Global Tick
        tick = self.clock.advance()

        # 2. 更新物候 & 全局状态（确定性）
        season, climate = self.phenology.update(tick)
        modifiers = self.phenology_registry.apply_all(season, climate, self.world)
        self.rule_engine.apply_modifiers(self.world, modifiers)

        # 3. 处理长程任务 & 检测中断
        interrupts = self.interrupt_mgr.check(self.world, tick)
        for interrupt in interrupts:
            self.rule_engine.resolve_interrupt(self.world, interrupt)

        # 4. 生成/刷新事件池，计算影响传播
        new_events = self.event_pool.generate(self.world, tick)
        self.knowledge.propagate(new_events, tick)

        # 5. 角色分层
        assignments = self.spotlight.assign(self.world.characters, new_events)

        # 6. 对 ACTIVE 角色调用 LLM
        for char in assignments.active:
            context = self.knowledge.build_context(char)
            intent = await self.character_agent.generate_intent(char, context)

            # Narrator 裁定
            verdict = self.narrator_verdict(intent, char, self.world)
            if verdict.approved:
                # 确定性打包 + DM Agent 结算
                settlement_ctx = self.build_settlement_context(intent, char, self.world)
                result = await self.dm_agent.settle(settlement_ctx)
                self.rule_engine.apply_result(self.world, result)
            else:
                # 重试 / Fallback
                intent = await self.retry.handle(char, context, verdict, max_retries=3)
                # ...

        # 7. 对 PASSIVE 角色执行规则更新
        for char in assignments.passive:
            self.rule_engine.passive_update(self.world, char, tick)

        # 8. 写入日志 & Checkpoint
        self.persistence.save_tick(tick, self.world)
        self.persistence.checkpoint_if_needed(tick)

        return TickResult(tick=tick, ...)
```

---

## 6. 数据库 Schema（SQLite）

```sql
-- 世界状态快照
CREATE TABLE world_snapshots (
    tick        INTEGER PRIMARY KEY,
    state_json  TEXT NOT NULL,           -- 完整世界状态序列化
    seed        INTEGER NOT NULL,        -- 该 tick 使用的随机种子
    created_at  TEXT DEFAULT (datetime('now'))
);

-- 角色表
CREATE TABLE characters (
    id              TEXT PRIMARY KEY,
    name            TEXT NOT NULL,
    state_mode      TEXT NOT NULL CHECK(state_mode IN ('ACTIVE','PASSIVE','DORMANT')),
    location_id     TEXT NOT NULL,
    narrative_importance REAL DEFAULT 0.5,
    last_active_tick INTEGER DEFAULT 0,
    state_json      TEXT NOT NULL         -- 完整角色状态（status_effects, long_action 等）
);

-- 事件表
CREATE TABLE events (
    id              TEXT PRIMARY KEY,
    tick_created    INTEGER NOT NULL,
    tags            TEXT NOT NULL,         -- JSON array
    impact_scope    TEXT NOT NULL,         -- JSON
    hard_effects    TEXT,                  -- JSON array
    soft_prompts    TEXT,                  -- JSON array
    resolved        INTEGER DEFAULT 0
);

-- 事实表（客观知识）
CREATE TABLE facts (
    id              TEXT PRIMARY KEY,
    tick_created    INTEGER NOT NULL,
    content         TEXT NOT NULL,
    source_event_id TEXT REFERENCES events(id),
    visibility      TEXT NOT NULL DEFAULT 'global'  -- global / location / faction / private
);

-- 角色认知表（主观知识）
CREATE TABLE beliefs (
    character_id    TEXT NOT NULL REFERENCES characters(id),
    fact_id         TEXT NOT NULL REFERENCES facts(id),
    acquired_tick   INTEGER NOT NULL,
    confidence      REAL DEFAULT 1.0,      -- 1.0=确知, <1.0=传闻
    source_type     TEXT DEFAULT 'direct',  -- direct / rumor / inference
    PRIMARY KEY (character_id, fact_id)
);

-- 行动日志（完整审计链）
CREATE TABLE action_log (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    tick            INTEGER NOT NULL,
    character_id    TEXT NOT NULL,
    intent_json     TEXT NOT NULL,          -- 原始意图
    verdict         TEXT NOT NULL CHECK(verdict IN ('APPROVED','REJECTED','FALLBACK')),
    verdict_reason  TEXT,
    retry_count     INTEGER DEFAULT 0,
    result_json     TEXT,                   -- 结算结果
    is_fallback     INTEGER DEFAULT 0,
    fallback_reason TEXT,
    fallback_action TEXT,
    created_at      TEXT DEFAULT (datetime('now'))
);

-- 物候状态日志
CREATE TABLE phenology_log (
    tick            INTEGER PRIMARY KEY,
    season          TEXT NOT NULL,
    climate_json    TEXT NOT NULL,
    modifiers_json  TEXT NOT NULL           -- 本 tick 生效的物候修正
);

-- Checkpoints（快照恢复点）
CREATE TABLE checkpoints (
    tick            INTEGER PRIMARY KEY,
    world_snapshot  BLOB NOT NULL,          -- 压缩后的完整状态
    seed_state      BLOB NOT NULL           -- RNG 状态快照
);
```

---

## 7. 配置管理

使用 `YAML + Pydantic` 进行配置校验：

```yaml
# config/default.yaml
simulation:
  tick_unit_hours: 1          # 1 tick = 1 小时
  max_ticks: 10000
  checkpoint_interval: 100    # 每 100 tick 存档一次

narrator:
  max_retry: 3                # 意图被拒绝后最大重试次数
  instant_mode_max_rounds: 3  # 即时模式最大轮数

spotlight:
  weights:
    geo: 0.3
    relation: 0.2
    availability: 0.15
    narrative_importance: 0.25
    random_noise: 0.1
  threshold_active: 0.7
  threshold_passive: 0.3

phenology:
  enabled_effects:
    - winter_march_penalty
    - rain_disease_boost
    - famine_food_reduction

llm:
  default_provider: openai
  providers:
    openai:
      model: gpt-4o
      api_key: ${OPENAI_API_KEY}    # 环境变量引用
      max_tokens: 2048
    anthropic:
      model: claude-sonnet-4-20250514
      api_key: ${ANTHROPIC_API_KEY}
    ollama:
      model: llama3
      base_url: http://localhost:11434

persistence:
  db_path: data/narrator.db
  enable_wal: true              # SQLite WAL 模式提升并发性能
```

```python
# src/narrator/config.py
from pydantic import BaseModel
import yaml, os, re

class SimulationConfig(BaseModel):
    tick_unit_hours: int = 1
    max_ticks: int = 10000
    checkpoint_interval: int = 100

class SpotlightWeights(BaseModel):
    geo: float = 0.3
    relation: float = 0.2
    availability: float = 0.15
    narrative_importance: float = 0.25
    random_noise: float = 0.1

# ... 其他配置类

class AppConfig(BaseModel):
    simulation: SimulationConfig
    narrator: NarratorConfig
    spotlight: SpotlightConfig
    phenology: PhenologyConfig
    llm: LLMConfig
    persistence: PersistenceConfig

def load_config(path: str = "config/default.yaml") -> AppConfig:
    """加载配置，支持 ${ENV_VAR} 环境变量替换"""
    ...
```

---

## 8. 测试策略

| 测试层级 | 覆盖范围 | 关键测试 |
|---|---|---|
| **单元测试** | 每个模块独立测试 | `clock` 单调递增、`rule_engine` 状态变更正确性、`spotlight` 分层计算、`intent` 白名单校验 |
| **集成测试** | 跨模块流程 | 主循环 1000 tick 无时间线撕裂、信息隔离不泄露、非法动作拦截率 100% |
| **重放测试** | 确定性验证 | 固定 seed 下同一存档重放，关键状态完全一致 |
| **LLM Mock** | Agent 层 | 使用 Mock Provider 模拟 LLM 响应，验证重试/fallback 逻辑 |

验收指标（对应阶段 A）：
1. 1000 tick 无时间线撕裂
2. 非法动作拦截率 100%
3. 平均每 tick LLM 调用数 < 总角色数的 40%

---

## 9. 实施步骤

### Step 1: 项目脚手架
- 创建目录结构
- 配置 `pyproject.toml`（依赖：`pydantic`, `aiosqlite`, `pyyaml`, `openai`, `anthropic`, `httpx`, `pytest`, `pytest-asyncio`）
- 创建 `config/default.yaml`
- 实现 `config.py` 配置加载

### Step 2: 领域模型 (`models/`)
- 定义所有 Pydantic 数据模型（Character, Event, WorldState, Action, ActionResult）
- 定义枚举（StateMode, Granularity, Verdict）

### Step 3: Simulation Core (`core/`)
- 实现 `GlobalClock`（tick 管理、tick→日期映射）
- 实现 `SeedManager`（全局 RNG、子种子 fork）
- 实现 `RuleEngine`（规则注册、匹配、执行）
- 实现 `InterruptManager`

### Step 4: 持久化层 (`persistence/`)
- SQLite 初始化与迁移
- Repository 模式实现
- Checkpoint 存档/恢复

### Step 5: 物候系统 (`phenology/`)
- 实现物候日历
- 实现 3 个初始硬约束（严冬行军惩罚、雨季疾病提升、歉收降粮）
- 实现注册表

### Step 6: LLM 抽象层 (`llm/`)
- 实现 `LLMProvider` 抽象基类
- 实现 OpenAI provider
- 实现 Anthropic provider
- 实现 Provider Router
- 定义结构化输出 Schema

### Step 7: Knowledge Layer (`knowledge/`)
- 实现 FactStore
- 实现 BeliefStore（信息隔离核心）
- 实现上下文构建（为角色过滤可见信息）

### Step 8: Agent Layer (`agents/`)
- 实现 CharacterAgent（生成意图）
- 实现 Intent 校验器 & 动作白名单
- 实现 DM Agent（无状态结算）
- 实现重试 & Fallback 机制

### Step 9: Narrative Orchestrator (`orchestrator/`)
- 实现 `NarratorController` 主循环
- 实现粒度决策
- 实现聚光灯选角
- 实现事件池

### Step 10: 集成测试 & 调试工具
- 编写主循环集成测试
- 编写重放一致性测试
- 实现 `scripts/replay.py` 调试工具
